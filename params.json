{"name":"Learn-scope","tagline":"Learning JS Scopes","body":"# Learning Javascript Scope\r\n\r\n### Scope\r\nThe JavaScript language has a few concepts of \"scope\", none of which are straightforward or easy to understand as a new JavaScript developer (and even some experienced JavaScript developers). \r\n\r\nIn JavaScript, scope refers to the current context of your code. Scopes can be _globally_ or _locally_ defined. Understanding JavaScript scope is key to writing bulletproof code and being a better developer. You'll understand where variables/functions are accessible, be able to change the scope of your code's context and be able to write faster and more maintainable code, as well as debug much faster.\r\n\r\n### Global Scope\r\nBefore you write a line of JavaScript, you're in what we call the `Global Scope`. If we declare a variable, it's defined globally:\r\n```javascript\r\n// global scope\r\nvar name = 'John Doe';\r\n```\r\n\r\n### Local Scope\r\nA local scope refers to any scope defined past the global scope. There is typically one global scope, and each function defined has its own (nested) local scope. Any function defined within another function has a local scope which is linked to the outer function.\r\n\r\nIf I define a function and create variables inside it, those variables becomes locally scoped. Take this example:\r\n\r\n```javascript\r\nvar test = \"I'm global\";\r\nfunction testScope() {\r\n  var test = \"I'm local\";\r\n  console.log (test);     \r\n}\r\ntestScope();           // output: I'm local\r\nconsole.log(test);     // output: I'm global\r\n```\r\n\r\nAny locally scoped items are not visible in the global scope - _unless_ exposed, meaning if I define functions or variables within a new scope, it's inaccessible _outside_ of that current scope. A simple example of this is the following:\r\n```javascript\r\nvar myFunction = function () {\r\n  var name = 'John Doe';\r\n  console.log(name); // John Doe\r\n};\r\n// Uncaught ReferenceError: name is not defined\r\nconsole.log(name);\r\n```\r\n\r\nThe variable `name` is scoped locally, it isn't exposed to the parent scope and therefore undefined.\r\n\r\nAnother Example is this - \r\n```javascript\r\nvar locales = {\r\n  europe: function() {          // The Europe continent's local scope\r\n    var myFriend = \"Monique\";\r\n    var france = function() {   // The France country's local scope\r\n      var paris = function() {  // The Paris city's local scope\r\n        console.log(myFriend);\r\n      };\r\n      paris();\r\n    };\r\n    france();\r\n  }\r\n};\r\nlocales.europe();\r\n```\r\nThis type of look up is called **lexical (static) scope**. The static structure of a program determines the variable scope. The scope of a variable is defined by its location within the source code, and nested functions have access to variables declared in their outer scope. No matter where a function is called from, or even how itâ€™s called, its lexical scope depends only by where the function was declared.\r\n\r\nIn JavaScript, variables with the same name can be specified at multiple layers of nested scope. In such case local variables gain priority over global variables. If you declare a local variable and a global variable with the same name, the local variable will take precedence when you use it inside a function. This type of behavior is called shadowing. Simply put, the inner variable shadows the outer.\r\n\r\n### Function scope\r\nAll scopes in JavaScript are created with `Function Scope` _only_, they aren't created by `for` or `while` loops or expression statements like `if` or `switch`. New functions = new scope - that's the rule. A simple example to demonstrate this scope creation:\r\n\r\n```javascript\r\n// Scope A\r\nvar myFunction = function () {\r\n  // Scope B\r\n  var myOtherFunction = function () {\r\n    // Scope C\r\n  };\r\n};\r\n```\r\n\r\nIt's easy to create new scope and create local variables/functions/objects.\r\n### Scope Chain\r\nScope chains establish the scope for a given function. Each function defined has its own nested scope as we know, and any function defined within another function has a local scope which is linked to the outer function - this link is called the chain. It's always the _position_ in the code that defines the scope. When resolving a variable, JavaScript starts at the innermost scope and searches outwards until it finds the variable/object/function it was looking for.\r\n\r\n### Scope and 'this'\r\nEach scope binds a different value of `this` depending on how the function is invoked. We've all used the `this` keyword, but not all of us understand it and how it differs when invoked. By default `this` refers to the outer most global object, the `window`. We can easily show how invoking functions in different ways binds the `this` value differently:\r\n\r\n```javascript\r\nvar myFunction = function () {\r\n  console.log(this); // this = global, [object Window]\r\n};\r\nmyFunction();\r\n\r\nvar myObject = {};\r\nmyObject.myMethod = function () {\r\n  console.log(this); // this = Object { myObject }\r\n};\r\n\r\nvar nav = document.querySelector('.nav'); // <nav class=\"nav\">\r\nvar toggleNav = function () {\r\n  console.log(this); // this = <nav> element\r\n};\r\nnav.addEventListener('click', toggleNav, false);\r\n```\r\n\r\nThere are also problems that we run into when dealing with the `this` value, for instance if I do this, even inside the same function the scope can be changed and the `this` value can be changed:\r\n\r\n```javascript\r\nvar nav = document.querySelector('.nav'); // <nav class=\"nav\">\r\nvar toggleNav = function () {\r\n  console.log(this); // <nav> element\r\n  setTimeout(function () {\r\n    console.log(this); // [object Window]\r\n  }, 1000);\r\n};\r\nnav.addEventListener('click', toggleNav, false);\r\n```\r\n\r\nSo what's happened here? We've created new scope which is not invoked from our event handler, so it defaults to the `window` Object as expected. There are several things we can do if we want to access the proper `this` value which isn't affected by the new scope. You might have seen this before, where we can cache a reference to the `this` value using a `that` variable and refer to the lexical binding:\r\n\r\n```javascript\r\nvar nav = document.querySelector('.nav'); // <nav class=\"nav\">\r\nvar toggleNav = function () {\r\n  var that = this;\r\n  console.log(that); // <nav> element\r\n  setTimeout(function () {\r\n    console.log(that); // <nav> element\r\n  }, 1000);\r\n};\r\nnav.addEventListener('click', toggleNav, false);\r\n```\r\n\r\nThis is a neat little trick to be able to use the proper `this` value and resolve problems with newly created scope.\r\n\r\n### Things to Remember\r\n- All declarations, both functions and variables, are hoisted to the top of the containing scope, before any part of your code is executed.\r\n- Functions are hoisted first, and then variables.\r\n- Function declarations have priority over variable declarations, but not over variable assignments.\r\n\r\n_Sources_\r\n- (http://doctrina.org/JavaScript:Why-Understanding-Scope-And-Closures-Matter.html)\r\n- (http://www.sitepoint.com/)\r\n- https://developer.mozilla.org/en-US/docs/Web/JavaScript\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}